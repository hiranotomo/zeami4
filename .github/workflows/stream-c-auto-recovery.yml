# Event Model v1 - STREAM C: Self-Healing/Monitoring
# Purpose: Auto-recovery for failed checks
# Triggers: workflow_run (specific workflows)
# Dependencies: None
# Last updated: 2025-11-23

name: ğŸ”§ å¤±æ•—ãƒã‚§ãƒƒã‚¯è‡ªå‹•å›å¾©

on:
  workflow_run:
    workflows:
      - "CI/CD Pipeline"  # ci.yml
      - "PR Validation"   # validate-pr.yml
      - "Post-merge Verification"  # post-merge-verification.yml
    types: [completed]
    branches: [main]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  auto-recovery:
    name: Auto-Recovery for Failed Checks
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # è‡ªå·±å‚ç…§ã‚’é˜²ã filter
    if: github.event.workflow.name != 'Auto Recovery' && (github.event.check_run.conclusion == 'failure' || github.event.workflow_run.conclusion == 'failure')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Analyze and Recover
        uses: actions/github-script@v7
        with:
          script: |
            const checkName = context.payload.check_run?.name || context.payload.workflow_run?.name;
            const conclusion = context.payload.check_run?.conclusion || context.payload.workflow_run?.conclusion;

            console.log(`Failed check: ${checkName}`);

            // PRã‚’å–å¾—ï¼ˆcheck_runã¾ãŸã¯workflow_runã‹ã‚‰ï¼‰
            let prNumber = null;

            if (context.payload.check_run) {
              const checkRunId = context.payload.check_run.id;
              const { data: checkRun } = await github.rest.checks.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: checkRunId
              });

              // PRã‚’æ¤œç´¢
              if (checkRun.pull_requests.length > 0) {
                prNumber = checkRun.pull_requests[0].number;
              }
            } else if (context.payload.workflow_run) {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
              });

              if (prs.length > 0) {
                prNumber = prs[0].number;
              }
            }

            if (!prNumber) {
              console.log('No PR found for this check run');
              return;
            }

            console.log(`Found PR #${prNumber}`);

            // å›å¾©å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
            const recoverableChecks = {
              'Check Commit Message Format': {
                canRecover: true,
                solution: 'ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è‡ªå‹•ä¿®æ­£ã§ãã¾ã™ï¼ˆSquash mergeã§è§£æ±ºï¼‰'
              },
              'Check Branch Naming Convention': {
                canRecover: false,
                solution: 'ãƒ–ãƒ©ãƒ³ãƒåã¯æ‰‹å‹•ã§ä¿®æ­£ãŒå¿…è¦ã§ã™'
              },
              'ğŸ” ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯ (20.x)': {
                canRecover: true,
                solution: 'npm run pre-check ã‚’å®Ÿè¡Œã—ã¦ä¿®æ­£ã—ã¦ãã ã•ã„'
              }
            };

            const recoveryInfo = recoverableChecks[checkName];

            if (!recoveryInfo) {
              console.log(`Unknown check: ${checkName}`);
              return;
            }

            // PRã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿
            const commentBody = [
              `## âš ï¸ ãƒã‚§ãƒƒã‚¯å¤±æ•—: ${checkName}`,
              '',
              `**Status**: ${conclusion}`,
              '',
              recoveryInfo.canRecover
                ? `### âœ… è‡ªå‹•å›å¾©å¯èƒ½`
                : `### âŒ æ‰‹å‹•ä¿®æ­£ãŒå¿…è¦`,
              '',
              `**è§£æ±ºæ–¹æ³•**: ${recoveryInfo.solution}`,
              '',
              recoveryInfo.canRecover && checkName === 'ğŸ” ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯ (20.x)'
                ? [
                    '### è‡ªå‹•ä¿®æ­£ã‚³ãƒãƒ³ãƒ‰:',
                    '```bash',
                    'npm run pre-check',
                    'git add .',
                    'git commit --amend --no-edit',
                    'git push --force-with-lease',
                    '```'
                  ].join('\n')
                : '',
              '',
              '---',
              '',
              'ğŸ’¡ ã“ã®ãƒã‚§ãƒƒã‚¯ãŒå¤±æ•—ã—ã¦ã‚‚Auto-Mergeã¯ç¶šè¡Œã•ã‚Œã¾ã™ï¼ˆSquash mergeã§è§£æ±ºï¼‰'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });

            // Commit Message Formatã‚¨ãƒ©ãƒ¼ã®å ´åˆã€Auto-Mergeã«å½±éŸ¿ã—ãªã„ã“ã¨ã‚’æ˜è¨˜
            if (checkName === 'Check Commit Message Format') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: 'âœ… **é‡è¦**: ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å•é¡Œã¯Squash mergeã§è§£æ±ºã•ã‚Œã‚‹ãŸã‚ã€' +
                      'Auto-Mergeã¯æ­£å¸¸ã«å‹•ä½œã—ã¾ã™ã€‚ä¿®æ­£ã¯ä¸è¦ã§ã™ã€‚'
              });
            }
