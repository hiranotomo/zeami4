# Event Model v1 - STREAM A: PR-Lifecycle
# Purpose: Validate commit message format
# Triggers: pull_request
# Dependencies: None
# Last updated: 2025-11-23

name: Validate Commit Message

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  validate-commit-message:
    name: Check Commit Message Format
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        id: checkout
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Handle checkout failure
        if: steps.checkout.outcome == 'failure'
        run: |
          echo "âš ï¸ Checkout failed - likely infrastructure error (Repository not found, API timeout, etc.)"
          echo "Skipping validation to avoid false positive workflow failures"
          echo "This is expected behavior during temporary GitHub API outages"

      - name: Validate commit messages
        if: steps.checkout.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            // Infrastructure error detection helper
            const isInfraError = (error) => {
              const infraPatterns = [
                'Repository not found',
                'API rate limit',
                'timeout',
                'ECONNRESET',
                'ETIMEDOUT'
              ];
              const errorMsg = error?.message || error?.toString() || '';
              return infraPatterns.some(p => errorMsg.includes(p));
            };

            // PR ã®å ´åˆã¯ base...head ã®ç¯„å›²ã€push ã®å ´åˆã¯æœ€æ–°1ã‚³ãƒŸãƒƒãƒˆ
            let commits = [];

            try {
              if (context.payload.pull_request) {
                // PRã®å…¨ã‚³ãƒŸãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                const { data: prCommits } = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number
                });
                commits = prCommits.map(c => ({
                  sha: c.sha.substring(0, 7),
                  message: c.commit.message
                }));
              } else {
                // ç›´æ¥pushã®å ´åˆã¯æœ€æ–°ã‚³ãƒŸãƒƒãƒˆã®ã¿
                const sha = context.sha;
                const message = execSync(`git log -1 --pretty=%B ${sha}`, { encoding: 'utf8' });
                commits = [{ sha: sha.substring(0, 7), message }];
              }
            } catch (error) {
              if (isInfraError(error)) {
                console.log('âš ï¸ Infrastructure error detected - skipping validation');
                console.log(`Error: ${error.message}`);
                return;  // Skip validation, don't fail
              }
              throw error;  // Re-throw if not infrastructure error
            }

            console.log(`Checking ${commits.length} commit(s)...`);

            // Issueç•ªå·ãƒ‘ã‚¿ãƒ¼ãƒ³: #æ•°å­—
            const issuePattern = /#\d+/;

            const invalidCommits = [];

            for (const commit of commits) {
              console.log(`\nCommit ${commit.sha}:`);
              console.log(commit.message);

              // ãƒãƒ¼ã‚¸ã‚³ãƒŸãƒƒãƒˆè§£æ±ºæ™‚ã®ã‚³ãƒŸãƒƒãƒˆã¯ã‚¹ã‚­ãƒƒãƒ—
              if (commit.message.includes('Merge') ||
                  commit.message.includes('Resolve merge conflict')) {
                console.log('â­ï¸ Skipping merge-related commit');
                continue;
              }

              if (!issuePattern.test(commit.message)) {
                invalidCommits.push(commit);
                console.log(`âŒ No issue reference found`);
              } else {
                const issueNumber = commit.message.match(issuePattern)[0];
                console.log(`âœ… Issue reference found: ${issueNumber}`);
              }
            }

            if (invalidCommits.length > 0) {
              const errorMessage = [
                `## âŒ ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«Issueç•ªå·ãŒã‚ã‚Šã¾ã›ã‚“`,
                '',
                `ä»¥ä¸‹ã®${invalidCommits.length}ä»¶ã®ã‚³ãƒŸãƒƒãƒˆã«Issueå‚ç…§ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“:`,
                '',
                invalidCommits.map(c => `- \`${c.sha}\`: ${c.message.split('\n')[0]}`).join('\n'),
                '',
                '### æ­£ã—ã„å½¢å¼:',
                '```',
                'fix: #95 èª¬æ˜',
                'feat: #97 èª¬æ˜',
                'docs: #100 èª¬æ˜',
                '```',
                '',
                '### ãªãœå¿…è¦ï¼Ÿ',
                '- ã‚³ãƒŸãƒƒãƒˆã¨Issueã®ç´ä»˜ã‘ã‚’ä¿è¨¼',
                '- å¤‰æ›´ç†ç”±ã®è¿½è·¡å¯èƒ½æ€§ã‚’ç¢ºä¿',
                '- LLMãŒIssueå‚ç…§ã‚’å¿˜ã‚Œã‚‹ã“ã¨ã‚’é˜²æ­¢',
                '',
                '### ä¿®æ­£æ–¹æ³•:',
                '',
                '#### æ–¹æ³•1: ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¿®æ­£ï¼ˆæ¨å¥¨ï¼‰',
                '```bash',
                'git commit --amend -m "fix: #Issueç•ªå· èª¬æ˜"',
                'git push --force-with-lease',
                '```',
                '',
                '#### æ–¹æ³•2: æ–°ã—ã„ã‚³ãƒŸãƒƒãƒˆã‚’è¿½åŠ ',
                '```bash',
                'git commit --allow-empty -m "fix: #Issueç•ªå· å‰ã®ã‚³ãƒŸãƒƒãƒˆã«Issueå‚ç…§è¿½åŠ "',
                'git push',
                '```',
                '',
                '### ä¾‹å¤–:',
                'ãƒãƒ¼ã‚¸ã‚³ãƒŸãƒƒãƒˆï¼ˆ"Merge pull request"ï¼‰ã¯è‡ªå‹•çš„ã«ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚'
              ].join('\n');

              // PRã®å ´åˆã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿
              if (context.payload.pull_request?.number) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: errorMessage
                });
              }

              core.setFailed(`::error title=ğŸ”´ å¯¾å¿œå¿…è¦: ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¤œè¨¼å¤±æ•—::${invalidCommits.length}ä»¶ã®ã‚³ãƒŸãƒƒãƒˆã«Issueç•ªå·ãŒã‚ã‚Šã¾ã›ã‚“`);
              core.setFailed(`${invalidCommits.length}ä»¶ã®ã‚³ãƒŸãƒƒãƒˆã«Issueç•ªå·ãŒã‚ã‚Šã¾ã›ã‚“`);
            } else {
              console.log(`\nâœ… All commits have issue references`);
              console.log(`::notice title=âœ… å¯¾å¿œä¸è¦: ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¤œè¨¼æˆåŠŸ::å…¨${commits.length}ä»¶ã®ã‚³ãƒŸãƒƒãƒˆã«Issueå‚ç…§ãŒã‚ã‚Šã¾ã™`);

              // PRã®å ´åˆã€æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
              if (context.payload.pull_request?.number) {
                const issueNumbers = commits
                  .map(c => c.message.match(issuePattern))
                  .filter(Boolean)
                  .map(m => m[0]);

                const uniqueIssues = [...new Set(issueNumbers)];

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `âœ… å…¨${commits.length}ä»¶ã®ã‚³ãƒŸãƒƒãƒˆã«Issueå‚ç…§ãŒã‚ã‚Šã¾ã™ (é–¢é€£Issue: ${uniqueIssues.join(', ')})`
                });
              }
            }
