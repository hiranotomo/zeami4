#!/usr/bin/env node

/**
 * Pre-Completion Check Script
 *
 * LLMãŒå®Œäº†å ±å‘Šã‚’ã™ã‚‹å‰ã«å¿…ãšå®Ÿè¡Œã™ã‚‹ãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã€‚
 * å•é¡Œã‚’æ¤œå‡ºã—ãŸå ´åˆã€è‡ªå‹•çš„ã«Issueã‚’ä½œæˆã—ã€å®Œäº†ã‚’é˜»æ­¢ã™ã‚‹ã€‚
 *
 * Usage:
 *   npm run pre-check
 *   node scripts/pre-completion-check.js
 */

const { execSync } = require('child_process');

// GitHub CLI ãŒåˆ©ç”¨å¯èƒ½ã‹ç¢ºèª
function checkGHCLI() {
  try {
    execSync('gh --version', { stdio: 'ignore' });
    return true;
  } catch (error) {
    console.error('âŒ Error: GitHub CLI (gh) is not installed or not in PATH');
    console.error('Please install: https://cli.github.com/');
    process.exit(1);
  }
}

// Open Issues ã‚’ãƒã‚§ãƒƒã‚¯
function checkOpenIssues() {
  try {
    const output = execSync('gh issue list --json number,title,labels --limit 100', {
      encoding: 'utf-8'
    });

    const issues = JSON.parse(output);
    const testIssues = issues.filter(i => i.title.includes('[TEST]'));
    const regularIssues = issues.filter(i => !i.title.includes('[TEST]'));

    return {
      total: issues.length,
      testIssues,
      regularIssues
    };
  } catch (error) {
    console.error('âš ï¸  Failed to check issues:', error.message);
    return { total: 0, testIssues: [], regularIssues: [] };
  }
}

// Open PRs ã‚’ãƒã‚§ãƒƒã‚¯
function checkOpenPRs() {
  try {
    const output = execSync('gh pr list --json number,title,headRefName --limit 100', {
      encoding: 'utf-8'
    });

    const prs = JSON.parse(output);
    const testPRs = prs.filter(p =>
      p.headRefName.startsWith('test-pr-') ||
      p.title.includes('[TEST]') ||
      p.title.includes('ãƒ†ã‚¹ãƒˆ:')
    );
    const regularPRs = prs.filter(p =>
      !p.headRefName.startsWith('test-pr-') &&
      !p.title.includes('[TEST]') &&
      !p.title.includes('ãƒ†ã‚¹ãƒˆ:')
    );

    return {
      total: prs.length,
      testPRs,
      regularPRs
    };
  } catch (error) {
    console.error('âš ï¸  Failed to check PRs:', error.message);
    return { total: 0, testPRs: [], regularPRs: [] };
  }
}

// Git status ã‚’ãƒã‚§ãƒƒã‚¯
function checkGitStatus() {
  try {
    const output = execSync('git status --porcelain', {
      encoding: 'utf-8'
    });

    const lines = output.trim().split('\n').filter(l => l);

    return {
      uncommitted: lines.length,
      files: lines
    };
  } catch (error) {
    console.error('âš ï¸  Failed to check git status:', error.message);
    return { uncommitted: 0, files: [] };
  }
}

// å•é¡Œã‚’ã‚‚ã¨ã«è‡ªå‹•çš„ã«Issueã‚’ä½œæˆ
async function autoCreateIssue(problems) {
  const issueBody = [
    '## ğŸ¤– å®Œäº†å ±å‘Šå‰ãƒã‚§ãƒƒã‚¯ã§æ¤œå‡ºã•ã‚ŒãŸå•é¡Œ',
    '',
    'ã“ã®Issueã¯ `pre-completion-check.js` ã«ã‚ˆã£ã¦è‡ªå‹•ä½œæˆã•ã‚Œã¾ã—ãŸã€‚',
    '',
    '### æ¤œå‡ºã•ã‚ŒãŸå•é¡Œ',
    ''
  ];

  problems.forEach(problem => {
    switch (problem.type) {
      case 'test-issues':
        issueBody.push(`- **${problem.count}å€‹ã®ãƒ†ã‚¹ãƒˆIssueãŒæ®‹ã£ã¦ã„ã¾ã™**`);
        problem.details.slice(0, 5).forEach(i => {
          issueBody.push(`  - #${i.number}: ${i.title}`);
        });
        if (problem.count > 5) {
          issueBody.push(`  - ... and ${problem.count - 5} more`);
        }
        break;

      case 'test-prs':
        issueBody.push(`- **${problem.count}å€‹ã®ãƒ†ã‚¹ãƒˆPRãŒæ®‹ã£ã¦ã„ã¾ã™**`);
        problem.details.slice(0, 5).forEach(p => {
          issueBody.push(`  - #${p.number}: ${p.title} (\`${p.headRefName}\`)`);
        });
        if (problem.count > 5) {
          issueBody.push(`  - ... and ${problem.count - 5} more`);
        }
        break;

      case 'uncommitted':
        issueBody.push(`- **${problem.count}å€‹ã®æœªã‚³ãƒŸãƒƒãƒˆå¤‰æ›´ãŒã‚ã‚Šã¾ã™**`);
        break;
    }
    issueBody.push('');
  });

  issueBody.push('### å¯¾å¿œãŒå¿…è¦ãªç†ç”±');
  issueBody.push('');
  issueBody.push('å®Œäº†å ±å‘Šã¯ã€Œã™ã¹ã¦ã®ä½œæ¥­ãŒå®Œäº†ã—ã€ãƒªãƒã‚¸ãƒˆãƒªãŒ ã‚¯ãƒªãƒ¼ãƒ³ãªçŠ¶æ…‹ã€ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã¹ãã§ã™ã€‚');
  issueBody.push('ä¸Šè¨˜ã®å•é¡Œã‚’è§£æ±ºã—ã¦ã‹ã‚‰å®Œäº†å ±å‘Šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚');
  issueBody.push('');
  issueBody.push('### ä¿®æ­£æ–¹æ³•');
  issueBody.push('');
  issueBody.push('```bash');
  issueBody.push('# ãƒ†ã‚¹ãƒˆIssue/PRã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—');
  issueBody.push('gh issue list --json number,title --jq \'.[] | select(.title | startswith("[TEST]")) | .number\' | xargs -I {} gh issue close {}');
  issueBody.push('gh pr list --json number,headRefName --jq \'.[] | select(.headRefName | startswith("test-pr-")) | .number\' | xargs -I {} gh pr close {} --delete-branch');
  issueBody.push('```');
  issueBody.push('');
  issueBody.push('---');
  issueBody.push('');
  issueBody.push('ğŸ¤– Auto-generated by pre-completion-check.js');

  const title = 'fix: å®Œäº†å ±å‘Šå‰ã«æ¤œå‡ºã•ã‚ŒãŸå•é¡Œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—';
  const body = issueBody.join('\n');

  try {
    const output = execSync(
      `gh issue create --title "${title}" --body "${body}" --label "auto-detected,bug"`,
      { encoding: 'utf-8' }
    );

    const issueUrl = output.trim();
    return issueUrl;
  } catch (error) {
    console.error('âš ï¸  Failed to create issue:', error.message);
    return null;
  }
}

// ãƒ¡ã‚¤ãƒ³å‡¦ç†
async function main() {
  console.log('ğŸ” Running pre-completion check...\n');

  // GitHub CLI ãƒã‚§ãƒƒã‚¯
  checkGHCLI();

  // å„ç¨®ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
  const issues = checkOpenIssues();
  const prs = checkOpenPRs();
  const git = checkGitStatus();

  // çµæœè¡¨ç¤º
  console.log('ğŸ“Š Check Results:');
  console.log(`  - Open issues: ${issues.total} (${issues.testIssues.length} test, ${issues.regularIssues.length} regular)`);
  console.log(`  - Open PRs: ${prs.total} (${prs.testPRs.length} test, ${prs.regularPRs.length} regular)`);
  console.log(`  - Uncommitted changes: ${git.uncommitted}`);
  console.log('');

  // å•é¡Œã‚’åé›†
  const problems = [];

  if (issues.testIssues.length > 0) {
    problems.push({
      type: 'test-issues',
      count: issues.testIssues.length,
      details: issues.testIssues
    });
  }

  if (prs.testPRs.length > 0) {
    problems.push({
      type: 'test-prs',
      count: prs.testPRs.length,
      details: prs.testPRs
    });
  }

  if (git.uncommitted > 0) {
    problems.push({
      type: 'uncommitted',
      count: git.uncommitted,
      details: git.files
    });
  }

  // å•é¡ŒãŒã‚ã‚‹å ´åˆ
  if (problems.length > 0) {
    console.log('âŒ Pre-completion check FAILED\n');

    problems.forEach(p => {
      console.log(`  âš ï¸  ${p.type}: ${p.count} items`);
    });
    console.log('');

    // Issueè‡ªå‹•ä½œæˆ
    console.log('ğŸ¤– Creating blocking issue...');
    const issueUrl = await autoCreateIssue(problems);

    if (issueUrl) {
      console.log(`âœ… Created: ${issueUrl}`);
    }
    console.log('');
    console.log('ğŸš« Cannot complete: blocking issues detected');
    console.log('   Please resolve the above issues before completion report.');

    process.exit(1);
  }

  // å•é¡ŒãŒãªã„å ´åˆ
  console.log('âœ… Pre-completion check PASSED\n');
  console.log('âœ¨ Ready for completion report!');

  process.exit(0);
}

// å®Ÿè¡Œ
main().catch(error => {
  console.error('âŒ Fatal error:', error);
  process.exit(1);
});
